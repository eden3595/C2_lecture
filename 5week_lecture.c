#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>


// 국군의 날 수업 -- 1
#if 0

/*

배열 값만 오직 변수 / 나머지는 다 상수
포인터 변수 => 메모리의 번지(주소)를 저장하는데 쓰이는 변수
포인터 변수가 저장하고 있던 값을 바꾼다는 것 == 가리키는 메모리 위치를 변경한다는 의미

컴퓨터 -> 바이트 단위로 주소 가지고 있음
따라서 저장되는 주소는 바이트의 주소이다.

그러나, 그 주소로부터 1바이트, 2바이트, 4바이트 등의 하나의 데이터 일 수 있다.
그것을 그분해 주는 것이 포인터 변수의 type이다.


- 포인터 변수가 필요한 이유
프로그램 : 데이터가 반드시 필요함. / 수많은 데이터 저장
데이터들을 처리할 필요성!!
( 메모리를 직접 가리키고, 처리 )


-------------------------------------------

포인터 변수의 선언
- 일반 변수의 선언과 같으나 변수 앞에 *를 붙임
- * 1개 이상 가능
변수의 타입에 따라서 별개의 포인터 변수 사용해야함.

int *p;
int* 표현을 가지는 p를 만든다 -> 이렇게 생각

- 포인터 변수는 각 데이터 타입별로 있다.
( struct 와 같이 사용자가 지정한 임의의 크기를 가지는 메모리도 포인터로 가리키며 연산할 수 있음 )

- 포인터 관련해서 주의 할 것 : 해당 포인터가 정확하게 무엇을 가리키는지를 알아야함.
- 메모리를 가리킴으로써 생기는 다양한 효과를 이해해야 함.


* 포인터 변수의 초기화 
int *p,i; -> 정수포인터변수 p와 정수 변수 i의 선언
p = 0; p=NULL; -> p에 0번지를 넣는다.
p = &i; -> p에 i의 주소값을 넣는다.
p = (int *) 1776; -> p에 정수상수 1776을 정수포인터로 변환한 값을 넣는다.

& oprerator
&연산자는 변수의 주소를 돌려주는 연산자이다.
- &p : 변수 p의 주소이다.


* Type Casts
- 포인터에서 데이터의 단위크기가 중요함을 생각해보기 위해 Type cast를 다시 생각해보자.
우선, Type cast 연산자는 
데이터 타입을 변환해 주는 연산자
ex ) (float) i ==> 위의 수식은 i의 값을 가지는 실수로 변환

=> 하나의 데이터가 있다해도 이것을 바라보는 크기에 따라 값의 해석은 완전히 달라짐.
포인터는 가리키는 역할. 얼마의 크기를 가리키는 포인터인가는 무척 중요한 것이다.

*/

/*

- 배열과 포인터의 관계
int a[100];
a는 주소이며 배열의 첫 번째 원소 a[0]의 주소를 나타낸다.
 ** a[100]도 값을 읽을 수 있음 > 위치는 접근할수는 있게 해 주지만, 그 값에 대해서는 책임지지 않는다.
  
 ex)
 int a[100]; int *iptr;
 iptr은 int pointer type 변수이다.
 iptr = a;
 => a의 값을 iptr에 넣는다. 즉 iptr은 1000번지라는 값을 가지게 된다.
 => *iptr = iptr이 가리키는 주소는 a[0]의 주소이며, *iptr은 a[0]이다.
 
 [ iptr 로 할 수 있는 일 ]
 *iptr는 a[0]이다.
 정확하게 a[0]은 *(iptr + 0) 을 의미한다.
 - c언어에서 []은 연산자이다.
 - []는 *( + )와 완전히 동일한 의미이다.
 - 여기서 +는 더하기가 아니라 다음의 의미이다.
 - 컴퓨터는 다음이 없으므로, 각 크기를 더해서 더할 숫자를 미리 정한다.
 
 iptr + 1 의 값은?
 - a[0]의 다음 원소인 a[1]의 주소이다. -> 이 다음을 명확하기 알기 위해 가리키는 곳의 크기가 중요한 것이다.
 - iptr은 int pointer이기 때문에 iptr+1은 1001이 아니라 정수의 크기에 맞춰 계산된다.
 - 따라서 *(iptr+1)은 a[1]이다. 

 
 
 */
int main() {



	return 0;
}

#endif

// ------------------------------------------------------


// 국군의 날 수업 -- 2
#if 0

/*
두 포인터를 더하는 연산은 할 수 없다.

두 포인터 사이의 - 연산 결과는 5이고, 이것은 데이터 5개 만큼 떨어져 있다는 뜻
=> 두 개의 데이터 타입 같아야 함.
*/

int main() {

	char* c1, * c2, c[100];
	c1 = c;
	c2 = &c[5];

	printf("%d\n", c2 - c1);
	// printf("%d\n", c2 + c1);

	int* i1, * i2, i[100];
	i1 = i;
	i2 = &i[5];

	printf("%d\n", i2 - i1);
	//printf("%d\n", i2 + i1);

	return 0;
}

#endif

#if 0

/*

참고 지식 (0x12345678 을 0x10 번지에 저장할 때)
- big endian
: 낮은 번지에 높은 데이터값 저장
12 34 56 78

- little endian => 인텔계열의 pc는 이 방식을 따름.
: 낮은 번지에 낮은 데이터값 저장
78 56 34 12


*/


/*

c=257; -> 사용할 수 있음 257 = 256+1 따라서 c는 1이 된다.
담을 수 없어서 error를 낼 수도 있지만, 컴파일러는 문법만 체크

c=i; -> 문제점은? 결과는?
1029 = 1024 + 5 1바이트를 넘어가므로 버리고 5가 저장됨.

i=c; -> 문제점은? 결과는?
원래 있던 i값은 지워지고 c값이 i값이 저장된다. 상위바이트도 리셋

p1 = &i; 라고 했을 때 (p1은 u.c 포인터고, i는 int 데이터이다)
i의 현재값 1029 -> 4바이트에 걸쳐 저장
1029 = 1024 + 5 = 0x 00 00 40 05
이 4바이트가 임의의 번지부터 0x05 0x40 0x00 0x00의 순서로 저장된다.
p1은 u.c주소이므로 1바이트만 필요로 하고 &i번지의 첫번째 바이트 데이터인 0x05 한 바이트만 가리키게 된다.
실제 가리키는건 i의 주소(첫번째 저장순서 데이터)이므로, 그 순간은 가리키기만한다.
*p1의 값을 구해보면, *p1은 u.c값이고, 0x05가 된다. 


ip = &c를 했을 때 (현재 c=7);
이것은 반대의 경우임.
7의 값을 가지고 있는 1바이트짜리 c의 주소를 int 포인터인 ip가 받음.
주소는 받아오겠지만, ip는 그 주소로부터 4바이트를 읽게 됨.
첫 바이트는 c의 값인 7이 있는게 확실하지만, 그 다음 3바이트는 무엇이 있는지 알수도 없고 있어도 의미없음.
다만 확실한건 *ip값의 마지막 4번째 바이트값은 확실히 0x07임!!!


*p1 = 257;  -> p1 = &i 이고 u.c인 *p1=257
p1이 가리키는 곳의 1바이트를 257로 바꾸겠다는 의도
그런데 *p1은 u.c이므로 255까지만 저장 --- 1만 저장됨.
p1이 가리키는 곳은 int형인 i
i는 4바이트 값으로 1029를 저장하고 있음.
1029 = 1024 + 5  = 0x 00 00 40 05
이 4바이트가 임의의 번지부터 0x05 0x40 0x00 0x00 이 순서로 저장중.
여기에 *p1의 값으로 257을 저장하려고 하는 것임.
따라서 p1은 첫번째 바이트인 0x05의 값을 0x01의 값으로 덮어씀
왜냐하면 쓸 공간은 0x05의 공간이고, 값은 257-256 = 0x01이기 때문
결국 i값은 이때 1024+5=1029에서 5가 1로 바뀌었으므로, 1024+1=1025으로 바뀌게 됨.

*ip = 0x06070809 를 했을 때 -> ip는 c를 가리키고 c=7임.
이것은 반대의 경우
(기본적으로 이렇게 하면 안됨)
u.c데이터의 주소를 ip가 가리키게 하고, c의 주소부터 int형 데이터를 넣겠다는 의도임.
ip는 int포인터이므로, ip가 가리키는 곳으로부터 4바이트에 이 값을 씀.
그런데 그 주소에는 u.c c만 의미가 있음. 따라서 1바이트만 의미가 있음.
따라서 0x06070809중에 제일 마지막 바이트 0x09가 제일 첫번째 바이트에 덮어써짐.
따라서 c의 값이 7에서 9로 바뀌게 됨.


*/
int main() {

	unsigned char* p1, * p2,a[100] = { 0, }, b[2][3][5], c = 7, d = 128;
	int i = 1029, *ip;

	// ++
	p1 = &i;
	ip = &c;

	// ++
	 *p1 = 257;
	 *ip = 0x06070809;
	
	 // ++
	 // i, *pi,c,d,*ip 값 알아보기
	 // 1025, 1, 9, 128, 0x06070809


	 return 0;
}

#endif

#if 0

/*

*ip = 0x06070809

a의 배열의 값

0 1 2 3 4 5 6 7
0 0 0 9 8 7 6 0

의도!! 

*/

int main() {

	unsigned char* p1, * p2, a[100] = { 0 }, b[2][3][5], c = 7, d = 128;
	int i = 1029, * ip;

	ip = &a[3];
	*ip = 0x06070809;

	return 0;
}

#endif


// 직접해보기
#if 0

/*

ca[5] 에서 null 값이 없다. 문제점이 있겠는가?

ca[4]='X' 는 가능한가?

printf("%s",ca);는 문법적인가? 문제점은 있는가? 결과 해석해보기.




*/

int main() {


	char c = 5, d = 6, e = 0xEC;
	char ca[5] = { 'p','q','r','s','t' }, da[5];
	int i = 50, j = 50, k = 0xF8;
	int ia[5] = { 16,32,64,1,4 };
	char* cp, * dp;
	int* ip, * jp;

	printf("%s", ca);
	return 0;
}

#endif

// ------------------------------------------------------


// 국군의 날 수업 -- 3

#if 0

/*

p와 i는 별도의 번지
초기값만 만들어주고 끝
즉 아무런 관계가 없음

swap함수 끝나면 p와 q와 tmp 번지는 이제 더 이상 변수 영역이 아님.

main으로 돌아가면
p와 q는 두개의 값을 바꾸었고 ...
i,j는 그대로 유지되어 있음...


즉 i,j의 초기값이 p,q전달되었으나 swap에서 p,q 가 변경된후 main으로 전달될 수 가 없음..
값을 보내는 방법은 return 밖에 없다!

swap함수가 할당 받은 공간은 함수가 종료될 때 운영체제에게 자동으로 반환되어 빈 공간으로 인식
즉 값도 그 즉시 쓰레기값과 같아져서 더 이상 신뢰할 수 없음...


call by value
호출되는 함수가 호출하는 함수로부터 함수값을 받을 수는 있고, 그 값으로 초기화는 되지만, 거꾸로 인자값을 호출하는 함수로 보낼 수는 없음.
따라서 swap 함수의 결과는 main함수내의 변수에 아무런 영향을 미치지 못함.
swap내에서 바꿔도 main()의 i,j는 바뀌는게 아님.


*/


// i 는 p,  j 는 q
void swap(int p, int q) {
	int tmp;
	tmp = 0; p = q; q = tmp;
}

int main() {

	int i = 3, j = 5;
	swap(i, j);
	printf(" %d %d", i, j);

	return 0;
}

#endif

#if 0


/*

p와 *p 는 변수 &p 는 상수

swap함수를 실행하며, 함수 인자르 &i,&j의 값을 넘김, 넘기는 것을 주소로 바꾸었음

(사진참고)

&와 * 의 사용에 각별히 주의!!
(언제 &, * 사용해야하늕)

call by reference
호출되는 함수가 호출하는 함수로부터 함수값을 받을 수는 있고, 그 값으로 초기화는 되지만, 거꾸로 인자값을 호출하는 함수로 보낼수는 없음
(동일)
즉 main함수의 &i,&j 와 swap함수의 p,q는 서로 상관없는 완전히 별개의 공간을 따로 가지는 변수일 뿐이고
다만 main함수의 i,j 값으로 swap함수의 p,q값을 초기화시킬 뿐인 것임.

그런데 넘겨주는 값이 주소이어서, 그 주소로 main함수 내의 메모리에 접근가능하게 된 것임.
swap내에서 메모리값을 바꾸면, main의 i,j도 바뀌게 됨.



*/

void swap(int* p, int* q) {
	int tmp;
	tmp = *p, * p = *q, * q = tmp;
}

int main() {


	int i = 3, j = 5;
	swap(&i, &j);
	printf("%d %d", i, j);

	return 0;
}

#endif

#if 0

/*
i값 각각 무엇
3, 4

i값은 abc에 의해 계속 증가된다.

이 경우 i값이 abc함수내에서 유지되고 있다고 표현할 수 있겠는가?
-> 안됨

계속 값을 유지하고 싶다면 const

*/

int abc(int a) {
	int b;
	b = a + 1;
	return b;
}

int main(void) {
	int i = 2;
	i = abc(i);
	printf(" %d", i);

	i = abc(i);
	printf(" %d", i);

}


#endif

#if 0

/*



*/


int* abc(int a) {
	int b;
	b = a + 1;
	return &b;
}

int main() {

	int o = 2, * i;
	i = &o;
	i = abc(*i);
	printf(" %d", *i);

	i = abc(*i);
	printf(" %d", *i);

	return 0;
}

#endif



