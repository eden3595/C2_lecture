#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>



#if 0

char a = 2, b = 7;

int main() {


	int i, j;

	for (i = 1; i < 9; i++, a = 2) {
		for (j = 2; j < b; j++, a++) {
			printf("%2d * %2d = %2d    ", j, i, j * i);
			
		}
		printf("\n");
	}
	
}

#endif

#if 0

int main() {


	unsigned char a = 0xf0, b = 0x0f;

	printf("%x", ~a & ~b);
	printf("\n%x", (~a & ~b));

}

#endif

// ------------ 추석기간 수업 자료 2 -------------------
#if 0

/*

상수 - 변하지 않는 값
변수 - 변하는 값

변수 / 상수는 꼭 필요하다

b가 257일 때 a=b; a=5; 무슨 차이가 있는지!!

컴퓨터에서 제일 작은 값의 형태 : 비트
비트 단위 사용은 없기에 바이트!! 바이트 형태가 변수가 됨

char a,b,c,d,e,f,g; 와 char a[7] 은 무엇이 같고 무엇이 다른가



*/

int main() {

	char a = 0; int b = 257;
	a = 5, b = 257;

	// 5 = 5;  => 5는 공간이 아니므로 저장 안돼
	// c 문법에 맞지 않는다. 

	a = b; // 오른쪽에 있는 값을 왼쪽에
	// 변수 공간의 크기 ... a는 1바이트
	// 257은 1바이트로 표현 불가 => 1바이트+1비트
	// 문제점이 생김!!
	
	return 0;
}

#endif

// 프로그램 1
#if 0

// char a,b,c,d,e,f,g; char x[7] 뭐가 다른가

int main() {

	char a, b, c, d;
	int i, j, k;
	char e, f, g;
	int l;
	char h;
	int m;
	char x[7];

	// 프로그램에서는 순서대로 만들었지만 vs에서 만든 변수의
	// 순서는 꼭 그렇지는 않다. 
	// 먼저 쓴 변수의 주소가 보통 크고, 나중에 쓴 변수의 주소가 보통 작은 값이다.
	// char 1바이트 int 4바이트
	// vs는 모든 변수를 12 바이트씩 떼어놓고 만들었다.
	
	// 반면 배열 x는 모든 데이터가 정확하게 1바이트씩 나란히 만들어져 있다.
	// 배열 x의 데이터의 주소는 증가하는 방향으로 정확하게 만들어져 있다. 


	m = 0;



	return 0;
}

#endif

// 프로그램 2
#if 0

// 전역 변수와 지역 변수의 주소 공간 비교 -> 공간 완전히 구분
// 전역변수와 지역변수의 주소 할당 방법이 다르다.
// 인접하게 정의된 변수라고 해서 실제 메모리도 인접한 것은 절대 아니다.
// 지역 변수는 함수가 끝나면 os에게 빈공간으로 반환 -> 관리에 주의해야함
int i, j;
char a, b;
char array1[7];

int main() {

	char c, d;
	int x, y;
	char array2[7];
	int m;

	m = 0;


	return 0;
}

#endif


// ------------ 추석기간 수업 자료 3 -------------------

#if 0

// 일반적으로 많이 사용하는 변수들의 차이 알아보기
// char, short, int, long
// unsigned char, unsigned int

// signed unsigned 부호 비트 값의 사용에 따른 값의 해석 방법만 달라지고, 그 전체 크기 (비트 수)에는 영향이 없다.


// signed => 첫번째 비트는 부호로만 따라서 7bit로만 숫자를 표현할 수 있음
// MSD    빼면 갯수는 똑같다.
// 왼쪽을 빼면 127까지
// 오른쪽을 빼면 254이지만 홀수 빠짐

// bit 연산
/*

29 = 00011101
12 = 00001100

and = 00001100
or =  00011101

or연산과 +연산은 관련이 없지만 우연히 같을 수도 있다. (올림에 따라)


상황에 따라 변수값은 값이 아니라 비트/바이트 배열로 봐야할 경우가 많다.
특히, 포인터 연산을 본격적이로 이용할 경우, 이것을 잘 이해하고 있어야 값의 전이를 명확하게 이해할 수 있게된다.



*/


/*

주소의 계산

각 변수가 할당된 주소의 계산을 확인
각 주소의 +1 -1 은 단순한 숫자 더하고 빼는 것이 아니라
다음번지 이전번지로 생각




*/



// x=c;를 실행한다면 x의 값을 얼마가 되겟는가?
int i;
char a;
char arr1[3];

int main() {

	char c = 5;
	int x = 258;
	char arr2[3];

	x = c;
	printf("%d", x);
	
	return 0;
}


#endif

// ------------ 추석기간 수업 자료 4 -------------------

#if 0

/*

배열 - 인덱스가 붙어 있는 자료형
변수의 종류에 관게없이 낮은번지ㅔ서 높은 번지로 문자가 저장된다.

다른 일반 변수들은 보통 먼저 정의된 변수가 높은 번지에 만들어지고
다음 정의된 변수가 낮은 번지에 만들어진다.

그러나 배열은 반드시 시작점부터 데이터크기만큼 증가하여, 순서대로 만들어진다.

배열 = 모든 데이터 형을 배열로 만들수 있음. 포인터도 배열의 데이터가 될 수 ㅣㅇㅆ음.

일정한 형태의 데이터가 같은 크기로 계속 반복되어 연속으로 저장된다.

그 중 char 문자는 문자열이라고 함. 연속으로 출력되는 등의 처리를 할 수 있기 때문에 다른 배열과 달리 주의를 기울여야한다.

- 배열의 초기화
int a[100]={1}; -> a[0] 그 이후의 원소는 모두 0이 된다.


- 문자열
null string 은 비어 있는 문자열이라고 생각하면 된다.
null은 문자열의 끝을 나타냄.
문자열은 문자의 집합이다.

문자열은 메모리에 어떻게 저장되는가
=> 변수의 종류에 관계없이 낮은 번지에서 높은 번지로 문자가 저장된다.

문자열은 문자의 집합이므로 char의 배열로 문자열을 나타낼 수 있음.

마지막 특수문자 = '\0'  = 0; 값을 바로 쓰면 이렇게 해도 돼

*/

int main() {


	int a = 3, b = 4;
	printf("%d %d", a, b);

	// 지역변수는 함수가 사라지만 공간을 인정받지 못함.
	// 배열이 아니므로 공간에 반드시 연속적으로 지정되지 못함.
	return 0;
}

#endif

// ------------ 추석기간 수업 자료 5 -------------------

#if 0

/*

1차원 배열에서의 주소와 그 표현
char a[12] = "i am a boy.";
첫번째 문자의 주소가 1000일 때

a는 1000이다. (주소, 상수)
a는 포인터 상수이다. 변경 불가. 할당 받음

&a[0] 은 a[0]문자의 주소인 상수이다.
&a[0] 은 a와 같다.

배열의 이름은 첫번째 덩어리의 주소를 나타낸다. 

문자열을 제외하고는 이런 식으로 배열 값을 할당하는 경우 없음.
문자열이 있으면 텍스트 영역에 일단 문자열 저장하고 char 배열인 변수공간에 그 문자열을 다시 복사
그리고 그 문자열의 첫번째 위치를 a로 나타냄.
컴파일러는 모든 변수 이름을 상대 주소로 바꾸어 처리한다. 변수명은 없어진다.
따라서 이 과정에서 char,int 등 모든 크기에 맞는 주소 계산이 이루어진다.
=> 실제 컴퓨터는 a라는 것은 모르고 실제 할당된 주소로 계산 처리한다.



a[0] ~ a[11] = 변수
a 및 &a[0]~&a[11] = 상수

int는 크기만 달라짐.
** &i[2]-&i[0] 했을 때 %d로 출력했을 때 8이 나오는 것이 아닌 2가 나옴.
* => 개수  주소 사이에 몇개가 있는지


*/


int main() {

	char addr, a[12] = "I am a boy.";

	printf(" %p\n", a);
	printf(" %p\n", &a[0]);
	printf(" %c\n", a[0]);
	printf(" %d\n", &a[2] - &a[0]); // 주소끼리의 차

	// a와 &a[0] 의 값이 같음을 알 수 있음
	// %p => 주소 형식으로 출력

	// 주소의 차이는 계산해서 구할 수 있음
	// 주소끼리의 합은 연산할 수 없다.
	// 그래서 &a[2] + &a[0]은 구할 수 없다. 허용되지 않음.

	return 0;
}

#endif

// ------------ 추석기간 수업 자료 6 -------------------

#if 0


/*

다차원 배열 - 2차원 이상의 배열을 의미함
-> 몇 개씩의 데이터가 묶여있는지 확인 ( 덩어리 )

첫번째 덩어리가 중요함!!! -> 주소 나타내기에




*/

int main() {

	int arr1[4];
	int arr2[3][4]; // 행렬로 생각 3*4  값 자체로 생각했을 때는 이렇게 생각

	// 먼저 3개 덩어리가 있다.
	// 각 덩어리 안에는 4개의 덩어리로 이루어져 있다. 
	// 메모리는 증가하는 방향으로...

	// for문 돌릴 때 행렬로 생각하면 오류에 빠지기쉬움...

	return 0;
}


#endif

#if 0


/*

다차원 배열의 실제 메모리 구성

1차원 배열과 동일 다만 접근 방법을 2차원적으로 해석할 뿐
2차원적으로 이해하는 것이 편함
그러나 물리적 위치를 정확하게 이해하기 위해 아까와 같은 것 생각

2차원 배열 : 선언과 동시에 초기화
case 1: 모든 요소들을 초기화 ( 권고 !! )
case 2: 행 단위로 일부 요소들만 초기화 (덩어리는 나눠놓았을때)
case 3: 1차원 배열 형태의 초기화  -> 헷갈릴수 있음

- 초기화 리스트에 의한 배열 크기의 결정  : 비어 있는 범위!! error 고려

3차원 배열의 선언과 의미
3차원적 메모리 구조를 의미함.
일반적으로 자주 쓰지는 않지만 물리적 배치와, 각 주소의 표현방법 정확하게 알고 있어야함.
(분야 목적에 따라 다름)

4차원 이상의 배열은 4차원의 형태가 되므로 구조적인 표현이 어려움.




*/

int main() {



	return 0;
}

#endif

// ------------ 추석기간 수업 자료 7 -------------------

// 해봐야함!!!
#if 0

/*

2차원 int 배열의 주소와 표현

int i[3][4] = { 100,200,300,400,500,}
 
첫번째 숫자의 주소가 1000일때
I는 1000이다. (첫번째 덩어리의 주소를 나타낸다.)
i는 포인터 상수이다. 변경불가, 할당받음
모든 주소는 모두 상수이다.

i[0]은 첫번째 덩어리중 다시 첫째 덩어리 주소 => 첫번째 int의 주소를 나타낸다.

i[0][0]은 데이터값

배열에서 값자체가 주소인데 다시&를 붙인것은 바깥쪽 덩어리를 나타낸다.

예를 들어 i[0]는 [0][0]값의 주소이며 &i[0]는 [0]의 주소, 즉 i와 같다.




*/

int main() {



	return 0;
}

#endif


// ------------ 추석기간 수업 자료 8 -------------------

#if 0

/*



*/

int main() {



	return 0;
}

#endif



