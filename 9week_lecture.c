#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

// 정렬과 탐색
/*

정렬과 탐색 ---- 배열과 포인터를 이용한 많은 응용 중 하나

(1차원 배열로)

정렬 : 크기순으로 오름차순이나 내림차순으로 나열

버블 정렬 bubble sort
: 인접한 레코드가 순서대로 되어 있지 않으면 교환
: 전체가 정렬될 때까지 비교 / 교환 계속

void bubble(int list[],int n)
-> 배열의 주소를 넘긴다. 메인에 있는 것을 바꾼다.

-----------------------------------------------------------------

탐색 : 찾아내는 것.. 탐색을 확장한것이 검색
- 탐색해서 찾아내지 못할 수 있음 ... 못찾을때에 대한 결과 반드시 포함

순차 탐색 ( 가장 쉬운 탐색 방법 )

이진 탐색 ( 조건을 만족하면 효율적 )
: $정렬된 배열$ 의 중앙에 위치한 원소와 비교 되풀이 ... 빠르고 효율적이며 구현하기 편리
(정렬되어 있는 것이 조건)!!!

다만, 3개의 위치 지정자(포인터)를 정밀하게 다뤄야만 한다. 순서,겹침 등

탐색은 데이터를 바꾸는 것이 아니라 $ 찾아내는 것 $이다.

정렬 - 주소만 받아와도 돼
탐색 - 데이터 바꾸는 것이 아니므로 const 붙이면 돼



*/



/*



*/

#if 0

// 원래 hello가 출력되는가?
// no
// abc를 입력하면 abc를 그 자리에 쓰려고 시도한다!!
// scanf -- s1이 가리키는 곳에 너가 입력한 것을 할당해줄게
// 하지만 hello가 쓰지 못하는 영역에 있기에 에러

// char s1[30] 이라면?
// 배열 만드는 순간 hello를 수정할 수 있는 공간으로..
// 그래서 내가 입력하는 것 가능

//=> hello 자리가 어디인가!!!!
//배열은 공간을 만들어서 그곳에 쓰려는것...

// 현재 이 프로그램은 자신의 고유한 공간이 없음!! 
// 무언가를 할당하려면 변수 공간을 만들어야함!!!!

/*

메모리 할당
정적할당 : 변수의 타입, 저장장소 등이 컴파일 시간에 결정
동적할당 : 변수의 타입, 저장장소 등이 수행시간에 결정

정적할당 

// 프로그램 시작부터 끝까지 내 공간
int i[100];
i[10] = 10;

--------------------------------------------------------------

동적 할당

// 처음 시작할 때는 공간이 없음
// 아래 함수를 만나면 생김.
int *aptr
aptr = (int *)malloc(100*sizeof(int));
// 이 크기를 만들었는데 이것은 어떤 타입이다..
aptr[10] = 10;
free(aptr) // 반드시 반환해야함
// 성격상 배열과 똑같지만 배열은 이름이 있지만.. 
// 접근하는 변수는 따로 있고 그 변수가 그 메모리를 가리킨다. 
// 하지만 메모리가 연속적인 것은 똑같다

항상 공간을 쓸때는 정적
잠깐 쓸때는 동적

int *pn;
pn = (int*)malloc(sizeof(int)*10)
// 타입 같아야함...
// 컴파일 시간에는 pn포인터를 위한 공간만 할당

free를 사용한 메모리 해제
동적 메모리의 할당과 해제는 프로그래머의 책임. 명시적으로 할당/해제 해주어야 함.

int *ps =(int*)malloc(sizeof(int));
free(ps);
free(ps); // 재해제 안돼

int jugs=5;
int *pi = &jugs

free(pi) // 할당 안했으므로 안돼 , malloc 안했으므로






*/

int main() {

	char *s1 = "hello";
	scanf("%s", s1);

	printf("%s\n", s1);


	return 0;
}

#endif

#if 0
#include <stdlib.h>

int main() {

	int* pn, i;

	pn = (int*)malloc(sizeof(int) * 10);
	// 40개 사용
	// 하지만 넘어가도 관계 안함 -- 안정된 공간이 아님.. 쓰지 않는 것이 좋음

	for (i = 0; i < 10; i++) {
		pn[i] = i * 10;
	}

	printf("%d, %d\n", pn[5], *(pn + 5));
	free(pn);

	return 0;
}


#endif

/*

2차원 배열을 할당하려면?

int**pn = mallo(sizeof(int)*row*col);

주소에 가면 주소가 또 있고 한번 더 가면 int가 있다.

임시의 변수에 2차원 배열과 같은 것을 할당하려면 2차원 배열이 어떻게 생겼는지

2차원 배열도 결국 물리적으로는 1차원 배열처럼 하나의 긴 것..
이와 같이 물리적으로 같은 것으로 만들지, 논리적으로 같은 모양으로 만들지 결정

-> 배열이라고 이야기 할 수 없음
-> 배열 크기를 모른다고 해서 못쓰는 것이 아니라 내 마음대로 쓰면 돼


malloc 하는 숫자의 크기가 중요한게 아니라 어떤 포인터에게 할당하느냐
혹은 어던 구조로 할당하느냐가 중요하다. malloc안의 함수 인자는  그냥
숫자이다.

따라서 malloc 함수의 인자로 row*col의 배열 구조를 나타낼 수는 없다.






*/

#if 0

// int iarray[3][4]; 와 같은 형태를 만들고자 할 때
int main() {

	int** m = (int**)malloc(sizeof(int*) * 3);

	m[0] = (int*)malloc(sizeof(int*) * 4); // 각각 연속
	m[1] = (int*)malloc(sizeof(int*) * 4);
	m[2] = (int*)malloc(sizeof(int*) * 4);
	// 차례차례로 구분해서 작성해주어야 함

	// 16*3 + 12 + 4


	// int(*m)[4]에 malloc을 할당해도 같다.

	// m관점에서는 배열이랑 쓰는 것과 독같음
	// 배열에서는 12개가 딱 붙어 있지만
	// 여기서는 4 4 4 따로 나눠져 있음.
	// [ ]는 주소를 계산하는 과정


	return 0;
}



#endif


#if 0

/*

"abcdefg" 문자열 상수를 가리키는 char* 변수 p가 있다.
count를 위한 int형 변수 i도 있다.

이 변수가, 실행 중에 (첫 코딩때는 정의되어 있지 않은)
소문자 26글자가 있는 문자열을 바꾸어 가리키게

char *p = "abcde"
scanf("", p) 이런식이면 되지 않는다.


-------------------------------------------------
입력 받는 소문자 26개는 문자열인가? 문자인가?
입력 받는 소문자 26개는 변수인가? 상수인가?
상수이면 왜 상수이고, 변수이면 무엇이 변수인가?
변수 p는 그 크기가 1개에서 26개로 변경된 것인가?
아니면 7개에서 26개로 변경된 것인가? 
혹은 그것이 아닌 다른건가?



*/

int main() {

	char* p = "abcdefg";
	int count = 0;

	p = malloc(sizeof(char) * 27);

	scanf("%s", p);

	printf("%s", p);

	free(p);

	// scanf에서 &p가 아니라 p를 사용했는가?

	return 0;
}



#endif

#if 0

/*

이중 포인터 : 포인터를 가리키는 포인터
int i=100; // i는 int형 변수
int *p = &i; // p는 i를 가리키는 포인터
int **q = &p; // q는 포인터 p를 가리키는 이중 포인터

// 해석하는 것이 어떻게 보는지가 중요!!


*/

int main() {

	int i = 100;
	int* p = &i;
	int** q = &p;

	*p = 200;
	printf("i=%d  *p = %d  **q = %d\n", i, *p, **q);

	**q = 300;
	printf("i=%d  *p = %d  **q = %d", i, *p, **q);


	// q[0] ??

	return 0;
}


#endif

#if 0

/*



*/

void set_preverb(char** q) {
	
	static char* str1 = "A friend in need is a friend indeed";
	static char* str2 = "A little knowledge is a dangerous thing";

	*q = str1;
}


int main() {

	char* s = NULL;
	set_proverb(&s);
	printf("%s", s);

	return 0;
}

#endif